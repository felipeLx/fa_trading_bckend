# filepath: /home/felipelx/Desktop/workspace/fa_trading_bckend/qs_test.py# QuantConnect Algorithmic Trading Example# This example demonstrates using QuantConnect's LEAN engine for algorithmic tradingimport pandas as pdimport numpy as npimport matplotlib.pyplot as pltimport datetimeimport timeimport jsonimport osimport sys# QuantConnect LEAN engine and API libraries# Note: These need to be installed via pip install quantconnect-leantry:    from quantconnect import ApiConnection    from quantconnect.api import Api    from quantconnect.algorithm import QCAlgorithm    from quantconnect.research import QuantBookexcept ImportError:    print(\"QuantConnect libraries not found. Please install with:\")    print(\"pip install quantconnect-lean quantconnect-stubs\")    sys.exit(1)class QSConnectorDemo:    \"\"\"Class to manage connection to QuantConnect's API\"\"\"        def __init__(self, user_id=None, token=None):        \"\"\"Initialize with user credentials or load from config\"\"\"        self.user_id = user_id        self.token = token                if not user_id or not token:            self._load_credentials()                    self.api = Api(self.user_id, self.token)        def _load_credentials(self):        \"\"\"Load credentials from config file\"\"\"        try:            # Create a credentials file with your QuantConnect API details            # or modify this to fit your credential storage method            config_path = os.path.expanduser(\"~/.quantconnect/credentials.json\")            if os.path.exists(config_path):                with open(config_path, 'r') as f:                    config = json.load(f)                    self.user_id = config.get('user_id')                    self.token = config.get('token')            else:                print(\"No credentials file found. Using default or provided credentials.\")        except Exception as e:            print(f\"Error loading credentials: {e}\")        def list_projects(self):        \"\"\"List all projects in the account\"\"\"        return self.api.list_projects()        def create_project(self, name, description=\"\"):        \"\"\"Create a new project\"\"\"        return self.api.create_project(name, description)        def download_data(self, symbol, resolution=\"daily\", start_date=None, end_date=None):        \"\"\"Download market data for a specified symbol\"\"\"        # In a real implementation, this would use QC's data APIs        # This is a simplified placeholder        print(f\"Downloading {resolution} data for {symbol}\")        # Return dummy data for demonstration        start = start_date or datetime.datetime.now() - datetime.timedelta(days=365)        end = end_date or datetime.datetime.now()        date_range = pd.date_range(start=start, end=end, freq='D')                # Create dummy price data        np.random.seed(42)  # For reproducibility        prices = 100 + np.cumsum(np.random.randn(len(date_range)) * 2)                df = pd.DataFrame({            'open': prices * 0.99,            'high': prices * 1.02,            'low': prices * 0.98,            'close': prices,            'volume': np.random.randint(1000, 100000, size=len(date_range))        }, index=date_range)                return dfclass QSResearchDemo:    \"\"\"Class to demonstrate QuantConnect research functionality\"\"\"        def __init__(self, connector):        self.connector = connector            def analyze_stock(self, symbol, lookback_days=365):        \"\"\"Analyze a stock using basic technical indicators\"\"\"        # Get historical data        end_date = datetime.datetime.now()        start_date = end_date - datetime.timedelta(days=lookback_days)        data = self.connector.download_data(symbol, start_date=start_date, end_date=end_date)                # Calculate simple technical indicators        data['sma_20'] = data['close'].rolling(window=20).mean()        data['sma_50'] = data['close'].rolling(window=50).mean()        data['rsi'] = self._calculate_rsi(data['close'], window=14)                # Plot the analysis        self._plot_analysis(symbol, data)                return data        def _calculate_rsi(self, prices, window=14):        \"\"\"Calculate Relative Strength Index\"\"\"        delta = prices.diff()        gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()        loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()                rs = gain / loss        rsi = 100 - (100 / (1 + rs))        return rsi        def _plot_analysis(self, symbol, data):        \"\"\"Plot price and indicators\"\"\"        plt.figure(figsize=(12, 10))                # Price and moving averages        ax1 = plt.subplot(2, 1, 1)        ax1.plot(data.index, data['close'], label='Price')        ax1.plot(data.index, data['sma_20'], label='SMA 20')        ax1.plot(data.index, data['sma_50'], label='SMA 50')        ax1.set_title(f'{symbol} - Price and Moving Averages')        ax1.legend()                # RSI        ax2 = plt.subplot(2, 1, 2)        ax2.plot(data.index, data['rsi'], color='purple')        ax2.axhline(y=70, color='r', linestyle='-')        ax2.axhline(y=30, color='g', linestyle='-')        ax2.set_ylim([0, 100])        ax2.set_title('RSI (14)')                plt.tight_layout()        plt.show()class QSWorkflowDemo:    \"\"\"Class to demonstrate a typical QuantConnect workflow\"\"\"        def __init__(self, connector):        self.connector = connector        self.research = QSResearchDemo(connector)        def backtest_strategy(self, symbol, start_date=None, end_date=None):        \"\"\"Backtest a simple trading strategy\"\"\"        # In a real implementation, this would utilize QC's backtesting engine        # Here we're simulating the process        print(f\"Starting backtest for {symbol}\")                # Get historical data        end = end_date or datetime.datetime.now()        start = start_date or (end - datetime.timedelta(days=365))        data = self.connector.download_data(symbol, start_date=start, end_date=end)                # Add indicators        data['sma_20'] = data['close'].rolling(window=20).mean()        data['sma_50'] = data['close'].rolling(window=50).mean()                # Simple strategy: Buy when 20-day SMA crosses above 50-day SMA        # Sell when 20-day SMA crosses below 50-day SMA        data['signal'] = 0        data.loc[data['sma_20'] > data['sma_50'], 'signal'] = 1        data['position'] = data['signal'].diff()                # Calculate returns        data['returns'] = data['close'].pct_change()        data['strategy_returns'] = data['signal'].shift(1) * data['returns']                # Calculate performance metrics        cumulative_returns = (1 + data['returns']).cumprod() - 1        cumulative_strategy_returns = (1 + data['strategy_returns'].fillna(0)).cumprod() - 1                # Plot results        self._plot_backtest_results(symbol, data, cumulative_returns, cumulative_strategy_returns)                # Calculate performance metrics        sharpe = self._calculate_sharpe_ratio(data['strategy_returns'])        max_drawdown = self._calculate_max_drawdown(cumulative_strategy_returns)                return {            'sharpe_ratio': sharpe,            'max_drawdown': max_drawdown,            'total_return': cumulative_strategy_returns.iloc[-1]        }        def _calculate_sharpe_ratio(self, returns, risk_free_rate=0.02, annualization=252):        \"\"\"Calculate the Sharpe ratio of a return series\"\"\"        excess_returns = returns - risk_free_rate / annualization        return np.sqrt(annualization) * excess_returns.mean() / excess_returns.std()        def _calculate_max_drawdown(self, cumulative_returns):        \"\"\"Calculate the maximum drawdown of a cumulative return series\"\"\"        peak = cumulative_returns.cummax()        drawdown = (cumulative_returns - peak) / peak        return drawdown.min()        def _plot_backtest_results(self, symbol, data, cumulative_returns, cumulative_strategy_returns):        \"\"\"Plot backtest results\"\"\"        plt.figure(figsize=(12, 10))                # Price and moving averages with buy/sell signals        ax1 = plt.subplot(2, 1, 1)        ax1.plot(data.index, data['close'], label='Price')        ax1.plot(data.index, data['sma_20'], label='SMA 20')        ax1.plot(data.index, data['sma_50'], label='SMA 50')                # Plot buy signals        buy_signals = data[data['position'] == 1]        sell_signals = data[data['position'] == -1]        ax1.scatter(buy_signals.index, buy_signals['close'], marker='^', color='g', s=100)        ax1.scatter(sell_signals.index, sell_signals['close'], marker='v', color='r', s=100)                ax1.set_title(f'{symbol} - Price with Trading Signals')        ax1.legend()                # Cumulative returns comparison        ax2 = plt.subplot(2, 1, 2)        ax2.plot(data.index, cumulative_returns * 100, label='Buy and Hold (%)')        ax2.plot(data.index, cumulative_strategy_returns * 100, label='Strategy (%)')        ax2.set_title('Cumulative Returns (%)')        ax2.legend()                plt.tight_layout()        plt.show()class OmegaStrategyDemo:    \"\"\"Class to demonstrate a simple Omega strategy implementation\"\"\"        def __init__(self, symbols=None):        if symbols is None:            symbols = ['AAPL', 'MSFT', 'GOOGL', 'AMZN']        self.symbols = symbols        self.connector = QSConnectorDemo()        self.workflow = QSWorkflowDemo(self.connector)        def run_strategy(self):        \"\"\"Run the strategy across all symbols\"\"\"        results = {}        for symbol in self.symbols:            print(f\"\Analyzing {symbol}...\")            # First do research            self.research_symbol(symbol)                        # Then backtest            result = self.workflow.backtest_strategy(symbol)            results[symbol] = result            print(f\"Backtest results for {symbol}:\")            print(f\"  Sharpe Ratio: {result['sharpe_ratio']:.2f}\")            print(f\"  Max Drawdown: {result['max_drawdown']*100:.2f}%\")            print(f\"  Total Return: {result['total_return']*100:.2f}%\")                # Find the best performing symbol based on Sharpe ratio        best_symbol = max(results, key=lambda x: results[x]['sharpe_ratio'])        print(f\"\Best performing symbol: {best_symbol} with Sharpe ratio: {results[best_symbol]['sharpe_ratio']:.2f}\")                return results        def research_symbol(self, symbol):        \"\"\"Perform research on a specific symbol\"\"\"        print(f\"Researching {symbol}...\")        return self.workflow.research.analyze_stock(symbol, lookback_days=365)def main():    print(\"QuantConnect Algorithmic Trading Demo\")    print(\"-------------------------------------\")        # Step 1: Initialize Omega Strategy    print(\"\Initializing strategy...\")    strategy = OmegaStrategyDemo(['AAPL', 'MSFT', 'AMZN', 'GOOGL'])        # Step 2: Run the strategy    print(\"\Running strategy...\")    results = strategy.run_strategy()        # Step 3: Print summary    print(\"\Strategy execution complete!\")    print(\"In a real implementation, you would now deploy this to live trading.\")    print(\"To use actual QuantConnect functionality, you would need to:\")    print(\"1. Install the QuantConnect LEAN engine\")    print(\"2. Set up API credentials\")    print(\"3. Modify the code to use actual QC endpoints instead of simulations\")if __name__ == \"__main__\":    main()"